package {{apiPackage}}.cef;

import com.intellij.openapi.project.Project;
import {{apiPackage}}.routing.RouteTree;
import {{apiPackage}}.protocol.HttpMethod;
import {{apiPackage}}.protocol.ApiRequest;
import {{apiPackage}}.protocol.ApiResponse;
{{#apiInfo}}
{{#apis}}
import {{apiPackage}}.service.{{classname}}Service;
{{/apis}}
{{/apiInfo}}

import java.util.function.Function;
import java.util.List;
import java.util.ArrayList;

/**
 * Builder for ApiCefRequestHandler with fluent API.
 * Allows adding custom routes alongside generated API routes.
 * Auto-generated from OpenAPI specification.
 *
 * <p>Usage example:</p>
 * <pre>{@code
 * ApiCefRequestHandler handler = ApiCefRequestHandlerBuilder.builder(project)
 *     .withApiRoutes()
 *     .withPrefix("/custom", request -> ApiResponse.ok("Custom response"))
 *     .build();
 * }</pre>
 */
public final class ApiCefRequestHandlerBuilder {

    private final Project project;
    private final RouteTree routeTree = new RouteTree();
    private List<String> urlPrefixes = null; // null = accept all URLs

    private ApiCefRequestHandlerBuilder(Project project) {
        this.project = project;
    }

    /**
     * Create a new builder instance.
     *
     * @param project IntelliJ project instance
     * @return new ApiCefRequestHandlerBuilder
     */
    public static ApiCefRequestHandlerBuilder builder(Project project) {
        return new ApiCefRequestHandlerBuilder(project);
    }

    /**
     * Add all generated API routes from OpenAPI specification.
     * Registers route handlers for each operation defined in the spec.
     *
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withApiRoutes() {
{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
        routeTree.addRoute("{{path}}", HttpMethod.{{httpMethod}}, request -> {
            {{classname}}Service service = project.getService({{classname}}Service.class);
            return service.handle{{#lambda.titlecase}}{{operationId}}{{/lambda.titlecase}}(request);
        });
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
        return this;
    }

    /**
     * Add prefix route that matches if path starts with the specified prefix.
     * Useful for handling entire API namespaces or static file directories.
     *
     * @param prefix  URL prefix to match (e.g., "/api/v1", "/static")
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withPrefix("/static", HttpMethod.GET, staticFileHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withPrefix(String prefix, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addPrefixRoute(prefix, method, handler);
        return this;
    }

    /**
     * Add exact route that matches only if path equals exactly.
     * Provides precise routing for specific endpoints.
     *
     * @param path    exact URL path to match (e.g., "/health", "/api/status")
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withExact("/health", HttpMethod.GET, healthCheckHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withExact(String path, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addExactRoute(path, method, handler);
        return this;
    }

    /**
     * Add contains route that matches if path contains the specified substring.
     * Useful for wildcard-like matching patterns.
     *
     * @param substring substring to search for in path (e.g., ".json", "/admin/")
     * @param method    HTTP method to match (GET, POST, etc.)
     * @param handler   function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withContains(".json", HttpMethod.GET, jsonFileHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withContains(String substring, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addContainsRoute(substring, method, handler);
        return this;
    }

    /**
     * Set fallback handler for a specific HTTP method for requests that don't match any registered routes.
     * This handler will be called when no route matches the incoming request with the specified HTTP method.
     *
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler fallback handler function to process unmatched requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withFallback(HttpMethod.GET, request -> ApiResponse.ok("Default GET response"))
     *     .withFallback(HttpMethod.POST, request -> ApiResponse.notFound("POST not found"))
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withFallback(HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.setFallback(method, handler);
        return this;
    }

    /**
     * Enable URL filtering using server URLs from OpenAPI specification.
     * Only requests matching server URL prefixes will be handled by this handler.
     * Requests to other URLs will return null, allowing the browser to handle them.
     *
{{#hasServers}}
     * <p>Configured servers from OpenAPI spec:</p>
     * <ul>
{{#serverUrls}}
     *   <li>{{{.}}}</li>
{{/serverUrls}}
     * </ul>
{{/hasServers}}
{{^hasServers}}
     * <p>WARNING: No server URLs defined in OpenAPI specification.
     * URL filter will be empty. Consider using withUrlFilter(String...) instead.</p>
{{/hasServers}}
     *
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withUrlFilter() {
{{#hasServers}}
        this.urlPrefixes = new ArrayList<>();
{{#serverUrls}}
        this.urlPrefixes.add("{{{.}}}");
{{/serverUrls}}
{{/hasServers}}
{{^hasServers}}
        this.urlPrefixes = new ArrayList<>();
{{/hasServers}}
        return this;
    }

    /**
     * Enable URL filtering with custom URL prefixes.
     * Only requests matching specified URL prefixes will be handled by this handler.
     * Requests to other URLs will return null, allowing the browser to handle them.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withUrlFilter("http://localhost:8080", "http://localhost:8081")
     *     .withApiRoutes()
     *     .build();
     * }</pre>
     *
     * @param urlPrefixes URL prefixes to allow (e.g., "http://localhost:8080")
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withUrlFilter(String... urlPrefixes) {
        this.urlPrefixes = urlPrefixes == null || urlPrefixes.length == 0
            ? new ArrayList<>()
            : new ArrayList<>(List.of(urlPrefixes));
        return this;
    }

    /**
     * Build ApiCefRequestHandler with all configured routes.
     * Creates the final request handler ready for use with CEF browser.
     *
     * @return configured ApiCefRequestHandler instance
     */
    public ApiCefRequestHandler build() {
        return new ApiCefRequestHandler(project, routeTree, urlPrefixes);
    }
}
