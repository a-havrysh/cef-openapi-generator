package {{apiPackage}}.cef;

import com.intellij.openapi.project.Project;
import {{apiPackage}}.routing.RouteTree;
import {{apiPackage}}.protocol.HttpMethod;
import {{apiPackage}}.protocol.ApiRequest;
import {{apiPackage}}.protocol.ApiResponse;
{{#apiInfo}}
{{#apis}}
import {{apiPackage}}.service.{{classname}}Service;
{{/apis}}
{{/apiInfo}}
import {{modelPackage}}.*;

import java.util.function.Function;
import java.util.List;
import java.util.ArrayList;

/**
 * Builder for ApiCefRequestHandler with fluent API.
 * Allows adding custom routes alongside generated API routes.
 * Auto-generated from OpenAPI specification.
 *
 * <p>Usage example:</p>
 * <pre>{@code
 * ApiCefRequestHandler handler = ApiCefRequestHandlerBuilder.builder(project)
 *     .withApiRoutes()
 *     .withPrefix("/custom", request -> ApiResponse.ok("Custom response"))
 *     .build();
 * }</pre>
 */
public final class ApiCefRequestHandlerBuilder {

    private final Project project;
    private final RouteTree routeTree = new RouteTree();
    private List<String> urlPrefixes = null; // null = accept all URLs
    private final List<{{apiPackage}}.interceptor.RequestInterceptor> interceptors = new ArrayList<>();
    private final {{apiPackage}}.interceptor.CompositeExceptionHandler compositeExceptionHandler = new {{apiPackage}}.interceptor.CompositeExceptionHandler();
    private {{apiPackage}}.interceptor.ExceptionHandler exceptionHandler = null; // null = use composite

    private ApiCefRequestHandlerBuilder(Project project) {
        this.project = project;
    }

    /**
     * Create a new builder instance.
     *
     * @param project IntelliJ project instance
     * @return new ApiCefRequestHandlerBuilder
     */
    public static ApiCefRequestHandlerBuilder builder(Project project) {
        return new ApiCefRequestHandlerBuilder(project);
    }

    /**
     * Add all generated API routes from OpenAPI specification.
     * Registers route handlers for each operation defined in the spec.
     *
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withApiRoutes() {
{{#apiInfo}}
{{#apis}}
{{#operations}}
{{#operation}}
        routeTree.addRoute("{{path}}", HttpMethod.{{httpMethod}}, request -> {
            {{classname}}Service service = project.getService({{classname}}Service.class);
            return service.handle{{#lambda.titlecase}}{{operationId}}{{/lambda.titlecase}}({{#allParams}}{{#isPathParam}}request.getPathVariable("{{baseName}}"){{/isPathParam}}{{#isQueryParam}}{{#isInteger}}request.getQueryParam("{{baseName}}") != null ? Integer.parseInt(request.getQueryParam("{{baseName}}")) : null{{/isInteger}}{{#isLong}}request.getQueryParam("{{baseName}}") != null ? Long.parseLong(request.getQueryParam("{{baseName}}")) : null{{/isLong}}{{^isInteger}}{{^isLong}}request.getQueryParam("{{baseName}}"){{/isLong}}{{/isInteger}}{{/isQueryParam}}{{#isBodyParam}}request.getBody({{dataType}}.class){{/isBodyParam}}, {{/allParams}}request.getCefBrowser(), request.getCefFrame(), request.getCefRequest());
        });
{{/operation}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
        return this;
    }

    /**
     * Add custom route with path pattern (e.g., "/api/users/{id}").
     * Supports path variables that will be extracted during matching.
     *
     * @param pattern URL pattern with optional path variables (e.g., "/api/users/{id}")
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withRoute("/api/users/{id}", HttpMethod.GET, userHandler)
     *     .withRoute("/api/posts/{postId}/comments/{commentId}", HttpMethod.GET, commentHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withRoute(String pattern, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addRoute(pattern, method, handler);
        return this;
    }

    /**
     * Add prefix route that matches if path starts with the specified prefix.
     * Useful for handling entire API namespaces or static file directories.
     *
     * @param prefix  URL prefix to match (e.g., "/api/v1", "/static")
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withPrefix("/static", HttpMethod.GET, staticFileHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withPrefix(String prefix, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addPrefixRoute(prefix, method, handler);
        return this;
    }

    /**
     * Add exact route that matches only if path equals exactly.
     * Provides precise routing for specific endpoints.
     *
     * @param path    exact URL path to match (e.g., "/health", "/api/status")
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withExact("/health", HttpMethod.GET, healthCheckHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withExact(String path, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addExactRoute(path, method, handler);
        return this;
    }

    /**
     * Add contains route that matches if path contains the specified substring.
     * Useful for wildcard-like matching patterns.
     *
     * @param substring substring to search for in path (e.g., ".json", "/admin/")
     * @param method    HTTP method to match (GET, POST, etc.)
     * @param handler   function to process matching requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withContains(".json", HttpMethod.GET, jsonFileHandler)
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withContains(String substring, HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.addContainsRoute(substring, method, handler);
        return this;
    }

    /**
     * Set fallback handler for a specific HTTP method for requests that don't match any registered routes.
     * This handler will be called when no route matches the incoming request with the specified HTTP method.
     *
     * @param method  HTTP method to match (GET, POST, etc.)
     * @param handler fallback handler function to process unmatched requests
     * @return this builder for chaining
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withFallback(HttpMethod.GET, request -> ApiResponse.ok("Default GET response"))
     *     .withFallback(HttpMethod.POST, request -> ApiResponse.notFound("POST not found"))
     *     .build();
     * }</pre>
     */
    public ApiCefRequestHandlerBuilder withFallback(HttpMethod method, Function<ApiRequest, ApiResponse<?>> handler) {
        routeTree.setFallback(method, handler);
        return this;
    }

    /**
     * Enable URL filtering using server URLs from OpenAPI specification.
     * Only requests matching server URL prefixes will be handled by this handler.
     * Requests to other URLs will return null, allowing the browser to handle them.
     *
{{#hasServers}}
     * <p>Configured servers from OpenAPI spec:</p>
     * <ul>
{{#serverUrls}}
     *   <li>{{{.}}}</li>
{{/serverUrls}}
     * </ul>
{{/hasServers}}
{{^hasServers}}
     * <p>WARNING: No server URLs defined in OpenAPI specification.
     * URL filter will be empty. Consider using withUrlFilter(String...) instead.</p>
{{/hasServers}}
     *
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withUrlFilter() {
{{#hasServers}}
        this.urlPrefixes = new ArrayList<>();
{{#serverUrls}}
        this.urlPrefixes.add("{{{.}}}");
{{/serverUrls}}
{{/hasServers}}
{{^hasServers}}
        this.urlPrefixes = new ArrayList<>();
{{/hasServers}}
        return this;
    }

    /**
     * Enable URL filtering with custom URL prefixes.
     * Only requests matching specified URL prefixes will be handled by this handler.
     * Requests to other URLs will return null, allowing the browser to handle them.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withUrlFilter("http://localhost:8080", "http://localhost:8081")
     *     .withApiRoutes()
     *     .build();
     * }</pre>
     *
     * @param urlPrefixes URL prefixes to allow (e.g., "http://localhost:8080")
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withUrlFilter(String... urlPrefixes) {
        this.urlPrefixes = urlPrefixes == null || urlPrefixes.length == 0
            ? new ArrayList<>()
            : new ArrayList<>(List.of(urlPrefixes));
        return this;
    }

    /**
     * Enable CORS for all origins.
     * Adds CorsInterceptor with wildcard (*) origin support.
     * Automatically handles OPTIONS preflight requests.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withCors()
     *     .build();
     * }</pre>
     *
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withCors() {
        this.interceptors.add(new {{apiPackage}}.interceptor.CorsInterceptor(new ArrayList<>()));
        return this;
    }

    /**
     * Enable CORS for specific origins.
     * Adds CorsInterceptor with origin whitelist.
     * Only requests from specified origins will be allowed.
     * Automatically handles OPTIONS preflight requests.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withCors("http://localhost:3000", "https://example.com")
     *     .build();
     * }</pre>
     *
     * @param origins allowed origin URLs (e.g., "http://localhost:3000")
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withCors(String... origins) {
        List<String> originList = origins == null || origins.length == 0
            ? new ArrayList<>()
            : new ArrayList<>(List.of(origins));
        this.interceptors.add(new {{apiPackage}}.interceptor.CorsInterceptor(originList));
        return this;
    }

    /**
     * Enable OpenAPI parameter validation.
     * Adds ValidationInterceptor that validates all request parameters against OpenAPI constraints.
     * Automatically handles:
     * <ul>
     *   <li>Required parameter checks</li>
     *   <li>String length validation (minLength, maxLength)</li>
     *   <li>Numeric value validation (minimum, maximum)</li>
     *   <li>Pattern matching (regex)</li>
     *   <li>Enum value validation</li>
     * </ul>
     *
     * <p>Throws ValidationException (HTTP 400) with detailed error information if validation fails.</p>
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withValidation()
     *     .build();
     * }</pre>
     *
     * @return this builder for chaining
     * @see {{apiPackage}}.interceptor.ValidationInterceptor
     * @see {{apiPackage}}.exception.ValidationException
     */
    public ApiCefRequestHandlerBuilder withValidation() {
        this.interceptors.add(new {{apiPackage}}.interceptor.ValidationInterceptor());
        return this;
    }

    /**
     * Enable or disable OpenAPI parameter validation.
     * Convenience method to conditionally enable validation.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withValidation(true)  // enable validation
     *     .build();
     * }</pre>
     *
     * @param enabled whether to enable validation
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withValidation(boolean enabled) {
        if (enabled) {
            this.interceptors.add(new {{apiPackage}}.interceptor.ValidationInterceptor());
        }
        return this;
    }

    /**
     * Add request/response interceptor for cross-cutting concerns.
     * Interceptors are executed in registration order.
     *
     * <p>Common use cases:</p>
     * <ul>
     *   <li>Logging - log all requests and responses</li>
     *   <li>Metrics - track request count, duration, errors</li>
     *   <li>Authentication - validate tokens before handling</li>
     *   <li>Request ID tracking - correlation across logs</li>
     * </ul>
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withInterceptor(new LoggingInterceptor())
     *     .withInterceptor(new MetricsInterceptor())
     *     .build();
     * }</pre>
     *
     * @param interceptor request interceptor implementation
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withInterceptor({{apiPackage}}.interceptor.RequestInterceptor interceptor) {
        if (interceptor != null) {
            this.interceptors.add(interceptor);
        }
        return this;
    }

    /**
     * Register type-specific exception handler.
     * Handlers are checked in registration order using instanceof.
     * First matching handler processes the exception.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withExceptionHandler(ValidationException.class, (ex, req) -> {
     *         ErrorResponse err = new ErrorResponse();
     *         err.setError("Validation");
     *         err.setDetails(ex.getErrors());
     *         return ApiResponse.badRequest(err);
     *     })
     *     .withExceptionHandler(ApiException.class, (ex, req) -> {
     *         return ApiResponse.status(ex.getStatusCode(), ex.getMessage());
     *     })
     *     .withExceptionHandler(Exception.class, (ex, req) -> {
     *         return ApiResponse.internalServerError("Server error");
     *     })
     *     .build();
     * }</pre>
     *
     * @param exceptionType exception class to handle
     * @param handler handler for this exception type
     * @param <T> exception type
     * @return this builder for chaining
     */
    public <T extends Exception> ApiCefRequestHandlerBuilder withExceptionHandler(
            Class<T> exceptionType,
            {{apiPackage}}.interceptor.CompositeExceptionHandler.TypedExceptionHandler<T> handler) {
        compositeExceptionHandler.addHandler(exceptionType, handler);
        return this;
    }

    /**
     * Set custom exception handler for centralized error handling.
     * Default handler converts ApiException to appropriate HTTP status, others to 500.
     *
     * <p>Replaces composite handler. For type-specific handling use
     * {@link #withExceptionHandler(Class, CompositeExceptionHandler.TypedExceptionHandler)} instead.
     *
     * <p>Example:</p>
     * <pre>{@code
     * ApiCefRequestHandler handler = ApiCefRequestHandler.builder(project)
     *     .withApiRoutes()
     *     .withExceptionHandler((ex, req) -> {
     *         logger.error("Error handling " + req.getURL(), ex);
     *         if (ex instanceof ValidationException) {
     *             return ApiResponse.badRequest(ex.getMessage());
     *         }
     *         return ApiResponse.internalServerError("Server error");
     *     })
     *     .build();
     * }</pre>
     *
     * @param exceptionHandler custom exception handler
     * @return this builder for chaining
     */
    public ApiCefRequestHandlerBuilder withExceptionHandler({{apiPackage}}.interceptor.ExceptionHandler exceptionHandler) {
        if (exceptionHandler != null) {
            this.exceptionHandler = exceptionHandler;
        }
        return this;
    }

    /**
     * Build ApiCefRequestHandler with all configured routes.
     * Creates the final request handler ready for use with CEF browser.
     *
     * @return configured ApiCefRequestHandler instance
     */
    public ApiCefRequestHandler build() {
        // Use composite handler if no custom handler set
        {{apiPackage}}.interceptor.ExceptionHandler finalHandler = exceptionHandler != null
            ? exceptionHandler
            : compositeExceptionHandler;
        return new ApiCefRequestHandler(project, routeTree, urlPrefixes, interceptors, finalHandler);
    }
}
