package {{apiPackage}}.cef;

import {{apiPackage}}.protocol.ApiResponse;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.cef.callback.CefCallback;
import org.cef.handler.CefResourceHandlerAdapter;
import org.cef.misc.IntRef;
import org.cef.misc.StringRef;
import org.cef.network.CefRequest;
import org.cef.network.CefResponse;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.Math.min;
import static java.nio.ByteBuffer.wrap;

/**
 * CEF Resource Handler that converts ApiResponse to CEF format.
 * Handles serialization of response bodies and streaming data to CEF browser.
 * Auto-generated from OpenAPI specification.
 *
 * <p>Supports multiple response body types:</p>
 * <ul>
 *   <li>null - empty response with 204 No Content</li>
 *   <li>byte[] - raw binary data</li>
 *   <li>String - text data encoded as UTF-8</li>
 *   <li>Objects - serialized to JSON using Jackson</li>
 * </ul>
 *
 * <p>This class manages the complete lifecycle of a CEF resource response,
 * including headers, status codes, MIME types, and data streaming.</p>
 *
 * @see ApiResponse
 * @see CefResourceHandlerAdapter
 */
final class ApiResponseHandler extends CefResourceHandlerAdapter {

    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    private final ByteBuffer data;
    private final String contentType;
    private final int statusCode;
    private final String statusText;
    private final Map<String, String> headers;

    /**
     * Private constructor for factory methods only.
     *
     * @param data        response body as byte buffer
     * @param contentType MIME type of response
     * @param statusCode  HTTP status code
     * @param statusText  HTTP status text
     * @param headers     additional HTTP headers
     */
    private ApiResponseHandler(ByteBuffer data, String contentType, int statusCode, String statusText, Map<String, String> headers) {
        this.data = data;
        this.contentType = contentType;
        this.statusCode = statusCode;
        this.statusText = statusText;
        this.headers = headers != null ? headers : new HashMap<>();
    }

    /**
     * Create CEF resource handler from ApiResponse.
     * Automatically serializes body based on type.
     *
     * <p>Serialization strategy:</p>
     * <ul>
     *   <li>null body - returns empty handler</li>
     *   <li>byte[] - uses directly</li>
     *   <li>String - encodes as UTF-8</li>
     *   <li>Object - serializes to JSON</li>
     * </ul>
     *
     * @param response ApiResponse to convert
     * @return CEF resource handler, or empty handler if response is null
     */
    public static ApiResponseHandler from(ApiResponse<?> response) {
        return from(response, null, null);
    }

    /**
     * Create CEF resource handler from ApiResponse with CORS support.
     * Automatically adds CORS headers based on origin and allowed origins.
     *
     * @param response           ApiResponse to convert
     * @param origin             request origin header value
     * @param corsAllowedOrigins allowed CORS origins (empty = allow all)
     * @return CEF resource handler with CORS headers
     */
    public static ApiResponseHandler from(ApiResponse<?> response, String origin, List<String> corsAllowedOrigins) {
        if (response == null) {
            return empty();
        }

        Object body = response.getBody();
        String contentType = response.getContentType() != null ? response.getContentType() : "application/json";
        int statusCode = response.getStatusCode();

        Map<String, String> headers = new HashMap<>();
        if (corsAllowedOrigins != null && origin != null) {
            addCorsHeaders(headers, origin, corsAllowedOrigins);
        }

        if (body == null) {
            return new ApiResponseHandler(wrap(new byte[0]), contentType, statusCode, "OK", headers);
        }

        if (body instanceof byte[] bytes) {
            return new ApiResponseHandler(wrap(bytes), contentType, statusCode, "OK", headers);
        }

        if (body instanceof String text) {
            byte[] bytes = text.getBytes(StandardCharsets.UTF_8);
            return new ApiResponseHandler(wrap(bytes), contentType, statusCode, "OK", headers);
        }

        // Default: serialize to JSON
        try {
            String json = OBJECT_MAPPER.writeValueAsString(body);
            byte[] bytes = json.getBytes(StandardCharsets.UTF_8);
            return new ApiResponseHandler(wrap(bytes), contentType, statusCode, "OK", headers);
        } catch (Exception e) {
            return error(500, "Failed to serialize response: " + e.getMessage());
        }
    }

    /**
     * Create empty response handler (204 No Content).
     *
     * @return handler with no body and 204 status
     */
    public static ApiResponseHandler empty() {
        return new ApiResponseHandler(wrap(new byte[0]), "text/plain", 204, "No Content", null);
    }

    /**
     * Create error response handler with JSON error body.
     * Error body includes status, message, and timestamp.
     *
     * @param statusCode HTTP error status code (e.g., 404, 500)
     * @param message    error message to include in response
     * @return handler with JSON error response
     */
    public static ApiResponseHandler error(int statusCode, String message) {
        ErrorResponse errorResponse = new ErrorResponse(statusCode, message);
        try {
            String json = OBJECT_MAPPER.writeValueAsString(errorResponse);
            byte[] bytes = json.getBytes(StandardCharsets.UTF_8);
            return new ApiResponseHandler(wrap(bytes), "application/json", statusCode, message, null);
        } catch (Exception e) {
            String fallback = "{\"status\":" + statusCode + ",\"message\":\"" + message + "\"}";
            byte[] bytes = fallback.getBytes(StandardCharsets.UTF_8);
            return new ApiResponseHandler(wrap(bytes), "application/json", statusCode, message, null);
        }
    }

    /**
     * Create CORS preflight response for OPTIONS requests.
     * Returns 200 OK with appropriate CORS headers.
     *
     * @param origin             request origin header value
     * @param corsAllowedOrigins allowed CORS origins (empty = allow all)
     * @return handler with CORS preflight headers
     */
    public static ApiResponseHandler corsPreflightResponse(String origin, List<String> corsAllowedOrigins) {
        Map<String, String> headers = new HashMap<>();
        addCorsHeaders(headers, origin, corsAllowedOrigins);
        headers.put("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS");
        headers.put("Access-Control-Allow-Headers", "Content-Type, Authorization, Accept");
        headers.put("Access-Control-Max-Age", "86400"); // 24 hours

        return new ApiResponseHandler(wrap(new byte[0]), "text/plain", 200, "OK", headers);
    }

    /**
     * Add CORS headers to the response headers map.
     *
     * @param headers            headers map to add CORS headers to
     * @param origin             request origin header value
     * @param corsAllowedOrigins allowed CORS origins (empty = allow all)
     */
    private static void addCorsHeaders(Map<String, String> headers, String origin, List<String> corsAllowedOrigins) {
        if (corsAllowedOrigins == null) {
            return;
        }

        // Allow all origins if list is empty
        if (corsAllowedOrigins.isEmpty()) {
            headers.put("Access-Control-Allow-Origin", "*");
            headers.put("Access-Control-Allow-Credentials", "false");
        } else if (origin != null && corsAllowedOrigins.contains(origin)) {
            // Allow specific origin if it's in the allowed list
            headers.put("Access-Control-Allow-Origin", origin);
            headers.put("Access-Control-Allow-Credentials", "true");
        }
    }

    /**
     * Called by CEF to start processing the request.
     * Always returns true to indicate handler will provide data.
     *
     * @param request  CEF request object
     * @param callback callback to signal continuation
     * @return true to indicate processing will continue
     */
    @Override
    public boolean processRequest(CefRequest request, CefCallback callback) {
        callback.Continue();
        return true;
    }

    /**
     * Called by CEF to get response headers and metadata.
     * Sets status code, MIME type, content length, and custom headers.
     *
     * @param response       CEF response object to populate
     * @param responseLength output parameter for content length
     * @param redirectUrl    output parameter for redirect URL (unused)
     */
    @Override
    public void getResponseHeaders(CefResponse response, IntRef responseLength, StringRef redirectUrl) {
        response.setStatus(statusCode);
        response.setStatusText(statusText);
        response.setMimeType(contentType);
        responseLength.set(data.remaining());

        // Add custom headers (including CORS headers)
        if (!headers.isEmpty()) {
            response.setHeaderMap(headers);
        }
    }

    /**
     * Called by CEF to read response body data.
     * Streams data in chunks as requested by browser.
     *
     * @param buffer      buffer to write data into
     * @param bytesToRead maximum bytes to read
     * @param bytesRead   output parameter for actual bytes read
     * @param callback    callback for async operations (unused)
     * @return true if more data available, false when complete
     */
    @Override
    public boolean readResponse(byte[] buffer, int bytesToRead, IntRef bytesRead, CefCallback callback) {
        int toRead = min(bytesToRead, data.remaining());
        data.get(buffer, 0, toRead);
        bytesRead.set(toRead);
        return toRead > 0;
    }

    /**
     * Error response structure for JSON serialization.
     * Contains status code, error message, and timestamp.
     */
    private static final class ErrorResponse {
        private final int status;
        private final String message;
        private final long timestamp;

        /**
         * Create error response with current timestamp.
         *
         * @param status  HTTP status code
         * @param message error message
         */
        ErrorResponse(int status, String message) {
            this.status = status;
            this.message = message;
            this.timestamp = System.currentTimeMillis();
        }

        /**
         * Get HTTP status code.
         *
         * @return status code
         */
        public int getStatus() {
            return status;
        }

        /**
         * Get error message.
         *
         * @return error message
         */
        public String getMessage() {
            return message;
        }

        /**
         * Get timestamp when error occurred.
         *
         * @return Unix timestamp in milliseconds
         */
        public long getTimestamp() {
            return timestamp;
        }
    }
}
