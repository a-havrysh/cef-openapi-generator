package {{apiPackage}}.validation;

import {{apiPackage}}.exception.ValidationException.ValidationError;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Utility class for validating request parameters against OpenAPI constraints.
 *
 * <p>Provides thread-safe, stateless validation methods for different parameter types.
 * All methods return a list of {@link ValidationError} objects, allowing collection
 * of all validation failures before throwing an exception.
 *
 * <p>Supported validations:
 * <ul>
 *   <li>String constraints: required, minLength, maxLength, pattern (regex), enum</li>
 *   <li>Integer constraints: required, minimum, maximum</li>
 *   <li>Number constraints: required, minimum, maximum</li>
 * </ul>
 *
 * <p>Performance optimizations:
 * <ul>
 *   <li>Regex patterns are compiled once and cached in a thread-safe map</li>
 *   <li>All methods are static to avoid object allocation overhead</li>
 * </ul>
 *
 * <p>Auto-generated from OpenAPI specification.
 *
 * @see ValidationError
 */
public final class ParameterValidator {

    private ParameterValidator() {
        // Prevent instantiation
    }

    // Cache for compiled regex patterns (thread-safe)
    private static final Map<String, Pattern> PATTERN_CACHE = new ConcurrentHashMap<>();

    /**
     * Validates a string parameter against OpenAPI constraints.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Skip all other validations if value is null (optional parameter)</li>
     *   <li>MinLength, MaxLength, Pattern, Enum validations (all failures collected)</li>
     * </ol>
     *
     * @param paramName parameter name for error messages
     * @param value parameter value to validate (may be null)
     * @param required whether parameter is required
     * @param minLength minimum string length (null if no constraint)
     * @param maxLength maximum string length (null if no constraint)
     * @param pattern regex pattern (null if no constraint)
     * @param enumValues allowed values (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateString(
            String paramName,
            String value,
            boolean required,
            Integer minLength,
            Integer maxLength,
            String pattern,
            List<String> enumValues) {

        List<ValidationError> errors = new ArrayList<>();

        // Required check
        if (required && (value == null || value.isEmpty())) {
            errors.add(new ValidationError(paramName, value, "required",
                paramName + " is required"));
            return errors; // Don't validate other constraints if missing
        }

        // Skip other validations if value is null (optional parameter)
        if (value == null) {
            return errors;
        }

        // MinLength
        if (minLength != null && value.length() < minLength) {
            errors.add(new ValidationError(paramName, value, "minLength",
                paramName + " must be at least " + minLength + " characters (got " + value.length() + ")"));
        }

        // MaxLength
        if (maxLength != null && value.length() > maxLength) {
            errors.add(new ValidationError(paramName, value, "maxLength",
                paramName + " must be at most " + maxLength + " characters (got " + value.length() + ")"));
        }

        // Pattern
        if (pattern != null) {
            Pattern compiledPattern = PATTERN_CACHE.computeIfAbsent(pattern, Pattern::compile);
            if (!compiledPattern.matcher(value).matches()) {
                errors.add(new ValidationError(paramName, value, "pattern",
                    paramName + " must match pattern: " + pattern));
            }
        }

        // Enum
        if (enumValues != null && !enumValues.isEmpty() && !enumValues.contains(value)) {
            errors.add(new ValidationError(paramName, value, "enum",
                paramName + " must be one of: " + String.join(", ", enumValues)));
        }

        return errors;
    }

    /**
     * Validates an integer parameter against OpenAPI constraints.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Skip all other validations if value is null (optional parameter)</li>
     *   <li>Minimum, Maximum validations (all failures collected)</li>
     * </ol>
     *
     * @param paramName parameter name for error messages
     * @param value parameter value to validate (may be null)
     * @param required whether parameter is required
     * @param minimum minimum value (null if no constraint)
     * @param maximum maximum value (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateInteger(
            String paramName,
            Integer value,
            boolean required,
            Integer minimum,
            Integer maximum,
            Boolean exclusiveMinimum,
            Boolean exclusiveMaximum,
            Integer multipleOf) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && value == null) {
            errors.add(new ValidationError(paramName, null, "required",
                paramName + " is required"));
            return errors;
        }

        if (value == null) {
            return errors;
        }

        // Minimum (inclusive or exclusive)
        if (minimum != null) {
            if (exclusiveMinimum != null && exclusiveMinimum) {
                if (value <= minimum) {
                    errors.add(new ValidationError(paramName, value, "exclusiveMinimum",
                        paramName + " must be greater than " + minimum + " (got " + value + ")"));
                }
            } else {
                if (value < minimum) {
                    errors.add(new ValidationError(paramName, value, "minimum",
                        paramName + " must be at least " + minimum + " (got " + value + ")"));
                }
            }
        }

        // Maximum (inclusive or exclusive)
        if (maximum != null) {
            if (exclusiveMaximum != null && exclusiveMaximum) {
                if (value >= maximum) {
                    errors.add(new ValidationError(paramName, value, "exclusiveMaximum",
                        paramName + " must be less than " + maximum + " (got " + value + ")"));
                }
            } else {
                if (value > maximum) {
                    errors.add(new ValidationError(paramName, value, "maximum",
                        paramName + " must be at most " + maximum + " (got " + value + ")"));
                }
            }
        }

        // MultipleOf
        if (multipleOf != null && multipleOf > 0 && value % multipleOf != 0) {
            errors.add(new ValidationError(paramName, value, "multipleOf",
                paramName + " must be multiple of " + multipleOf + " (got " + value + ")"));
        }

        return errors;
    }

    /**
     * Validates a number (double/float) parameter against OpenAPI constraints.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Skip all other validations if value is null (optional parameter)</li>
     *   <li>Minimum, Maximum validations (all failures collected)</li>
     * </ol>
     *
     * @param paramName parameter name for error messages
     * @param value parameter value to validate (may be null)
     * @param required whether parameter is required
     * @param minimum minimum value (null if no constraint)
     * @param maximum maximum value (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateNumber(
            String paramName,
            Number value,
            boolean required,
            Number minimum,
            Number maximum,
            Boolean exclusiveMinimum,
            Boolean exclusiveMaximum,
            Number multipleOf) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && value == null) {
            errors.add(new ValidationError(paramName, null, "required",
                paramName + " is required"));
            return errors;
        }

        if (value == null) {
            return errors;
        }

        double doubleValue = value.doubleValue();

        // Minimum (inclusive or exclusive)
        if (minimum != null) {
            double minValue = minimum.doubleValue();
            if (exclusiveMinimum != null && exclusiveMinimum) {
                if (doubleValue <= minValue) {
                    errors.add(new ValidationError(paramName, value, "exclusiveMinimum",
                        paramName + " must be greater than " + minimum + " (got " + value + ")"));
                }
            } else {
                if (doubleValue < minValue) {
                    errors.add(new ValidationError(paramName, value, "minimum",
                        paramName + " must be at least " + minimum + " (got " + value + ")"));
                }
            }
        }

        // Maximum (inclusive or exclusive)
        if (maximum != null) {
            double maxValue = maximum.doubleValue();
            if (exclusiveMaximum != null && exclusiveMaximum) {
                if (doubleValue >= maxValue) {
                    errors.add(new ValidationError(paramName, value, "exclusiveMaximum",
                        paramName + " must be less than " + maximum + " (got " + value + ")"));
                }
            } else {
                if (doubleValue > maxValue) {
                    errors.add(new ValidationError(paramName, value, "maximum",
                        paramName + " must be at most " + maximum + " (got " + value + ")"));
                }
            }
        }

        // MultipleOf
        if (multipleOf != null && multipleOf.doubleValue() > 0) {
            double mul = multipleOf.doubleValue();
            double remainder = doubleValue % mul;
            if (Math.abs(remainder) > 1e-10 && Math.abs(remainder - mul) > 1e-10) {
                errors.add(new ValidationError(paramName, value, "multipleOf",
                    paramName + " must be multiple of " + multipleOf + " (got " + value + ")"));
            }
        }

        return errors;
    }

    /**
     * Parses a string to integer and validates constraints in one step.
     *
     * <p>This method is specifically designed for query/path/header parameters
     * which are extracted as strings but represent integer values.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Type check - attempts to parse as integer, fails if invalid format</li>
     *   <li>Delegates to {@link #validateInteger} for min/max validation</li>
     * </ol>
     *
     * @param paramName parameter name for error messages
     * @param stringValue parameter value as string (may be null)
     * @param required whether parameter is required
     * @param minimum minimum value (null if no constraint)
     * @param maximum maximum value (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateAndParseInteger(
            String paramName,
            String stringValue,
            boolean required,
            Integer minimum,
            Integer maximum) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (stringValue == null || stringValue.isEmpty())) {
            errors.add(new ValidationError(paramName, stringValue, "required",
                paramName + " is required"));
            return errors;
        }

        if (stringValue == null || stringValue.isEmpty()) {
            return errors;
        }

        Integer value;
        try {
            value = Integer.parseInt(stringValue);
        } catch (NumberFormatException e) {
            errors.add(new ValidationError(paramName, stringValue, "type",
                paramName + " must be a valid integer"));
            return errors;
        }

        return validateInteger(paramName, value, false, minimum, maximum, null, null, null);
    }

    /**
     * Parses a string to number (double) and validates constraints in one step.
     *
     * <p>This method is specifically designed for query/path/header parameters
     * which are extracted as strings but represent numeric values.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Type check - attempts to parse as double, fails if invalid format</li>
     *   <li>Delegates to {@link #validateNumber} for min/max validation</li>
     * </ol>
     *
     * @param paramName parameter name for error messages
     * @param stringValue parameter value as string (may be null)
     * @param required whether parameter is required
     * @param minimum minimum value (null if no constraint)
     * @param maximum maximum value (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateAndParseNumber(
            String paramName,
            String stringValue,
            boolean required,
            Number minimum,
            Number maximum) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (stringValue == null || stringValue.isEmpty())) {
            errors.add(new ValidationError(paramName, stringValue, "required",
                paramName + " is required"));
            return errors;
        }

        if (stringValue == null || stringValue.isEmpty()) {
            return errors;
        }

        Double value;
        try {
            value = Double.parseDouble(stringValue);
        } catch (NumberFormatException e) {
            errors.add(new ValidationError(paramName, stringValue, "type",
                paramName + " must be a valid number"));
            return errors;
        }

        return validateNumber(paramName, value, false, minimum, maximum, null, null, null);
    }

    /**
     * Validates and parses ISO 8601 date string (YYYY-MM-DD) to LocalDate.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Type check - attempts to parse as LocalDate, fails if invalid format</li>
     * </ol>
     *
     * <p>Accepts ISO 8601 date format: YYYY-MM-DD (e.g., "2026-01-11")
     *
     * @param paramName parameter name for error messages
     * @param stringValue date string (may be null)
     * @param required whether parameter is required
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateAndParseDate(
            String paramName,
            String stringValue,
            boolean required) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (stringValue == null || stringValue.isEmpty())) {
            errors.add(new ValidationError(paramName, stringValue, "required",
                paramName + " is required"));
            return errors;
        }

        if (stringValue == null || stringValue.isEmpty()) {
            return errors;
        }

        try {
            java.time.LocalDate.parse(stringValue);
        } catch (java.time.format.DateTimeParseException e) {
            errors.add(new ValidationError(paramName, stringValue, "format",
                paramName + " must be valid ISO 8601 date (YYYY-MM-DD)"));
        }

        return errors;
    }

    /**
     * Validates and parses ISO 8601 date-time string to OffsetDateTime.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Type check - attempts to parse as OffsetDateTime, fails if invalid format</li>
     * </ol>
     *
     * <p>Accepts ISO 8601 date-time format with timezone:
     * <ul>
     *   <li>2026-01-11T15:30:00Z</li>
     *   <li>2026-01-11T15:30:00+01:00</li>
     *   <li>2026-01-11T15:30:00.123456789Z</li>
     * </ul>
     *
     * @param paramName parameter name for error messages
     * @param stringValue date-time string (may be null)
     * @param required whether parameter is required
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateAndParseDateTime(
            String paramName,
            String stringValue,
            boolean required) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (stringValue == null || stringValue.isEmpty())) {
            errors.add(new ValidationError(paramName, stringValue, "required",
                paramName + " is required"));
            return errors;
        }

        if (stringValue == null || stringValue.isEmpty()) {
            return errors;
        }

        try {
            java.time.OffsetDateTime.parse(stringValue);
        } catch (java.time.format.DateTimeParseException e) {
            errors.add(new ValidationError(paramName, stringValue, "format",
                paramName + " must be valid ISO 8601 date-time"));
        }

        return errors;
    }

    /**
     * Validates and parses boolean parameter.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>Type check - attempts to parse as boolean, fails if invalid format</li>
     * </ol>
     *
     * <p>Accepts (case-insensitive):
     * <ul>
     *   <li>"true", "false" → Boolean</li>
     *   <li>"1" → true</li>
     *   <li>"0" → false</li>
     *   <li>"yes", "no" → Boolean (common)</li>
     *   <li>"on", "off" → Boolean (common)</li>
     * </ul>
     *
     * @param paramName parameter name for error messages
     * @param stringValue boolean string (may be null)
     * @param required whether parameter is required
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateAndParseBoolean(
            String paramName,
            String stringValue,
            boolean required) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (stringValue == null || stringValue.isEmpty())) {
            errors.add(new ValidationError(paramName, stringValue, "required",
                paramName + " is required"));
            return errors;
        }

        if (stringValue == null || stringValue.isEmpty()) {
            return errors;
        }

        String lowerValue = stringValue.toLowerCase();
        if (!lowerValue.equals("true") && !lowerValue.equals("false") &&
            !lowerValue.equals("1") && !lowerValue.equals("0") &&
            !lowerValue.equals("yes") && !lowerValue.equals("no") &&
            !lowerValue.equals("on") && !lowerValue.equals("off")) {
            errors.add(new ValidationError(paramName, stringValue, "type",
                paramName + " must be valid boolean (true/false, 1/0, yes/no, on/off)"));
        }

        return errors;
    }

    /**
     * Validates array parameter against OpenAPI constraints.
     *
     * <p>Validation order:
     * <ol>
     *   <li>Required check - if fails, returns immediately</li>
     *   <li>MinItems, MaxItems validation</li>
     *   <li>UniqueItems validation - checks for duplicates</li>
     *   <li>Item-level validation (if item constraints provided)</li>
     * </ol>
     *
     * <p>Array parsing from query string:
     * <ul>
     *   <li>"tag1,tag2,tag3" → List.of("tag1", "tag2", "tag3")</li>
     *   <li>"" (empty) → List.of()</li>
     *   <li>null → null</li>
     * </ul>
     *
     * @param paramName parameter name for error messages
     * @param value array as comma-separated string (may be null)
     * @param required whether parameter is required
     * @param minItems minimum number of items (null if no constraint)
     * @param maxItems maximum number of items (null if no constraint)
     * @param uniqueItems whether items must be unique (null if no constraint)
     * @param itemEnumValues allowed values for each item (null if no constraint)
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateArray(
            String paramName,
            String value,
            boolean required,
            Integer minItems,
            Integer maxItems,
            Boolean uniqueItems,
            List<String> itemEnumValues) {

        List<ValidationError> errors = new ArrayList<>();

        // Parse array from comma-separated string
        List<String> items = null;
        if (value != null && !value.isEmpty()) {
            items = java.util.Arrays.asList(value.split(","));
            // Trim whitespace from each item
            items = items.stream()
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(java.util.stream.Collectors.toList());
        }

        // Required check
        if (required && (items == null || items.isEmpty())) {
            errors.add(new ValidationError(paramName, value, "required",
                paramName + " is required"));
            return errors;
        }

        // Skip other validations if array is null/empty (optional parameter)
        if (items == null || items.isEmpty()) {
            return errors;
        }

        // MinItems
        if (minItems != null && items.size() < minItems) {
            errors.add(new ValidationError(paramName, value, "minItems",
                paramName + " must have at least " + minItems + " item(s) (got " + items.size() + ")"));
        }

        // MaxItems
        if (maxItems != null && items.size() > maxItems) {
            errors.add(new ValidationError(paramName, value, "maxItems",
                paramName + " must have at most " + maxItems + " item(s) (got " + items.size() + ")"));
        }

        // UniqueItems
        if (uniqueItems != null && uniqueItems) {
            long uniqueCount = items.stream().distinct().count();
            if (uniqueCount < items.size()) {
                errors.add(new ValidationError(paramName, value, "uniqueItems",
                    paramName + " must have unique items (found " + (items.size() - uniqueCount) + " duplicate(s))"));
            }
        }

        // Validate each item against enum
        if (itemEnumValues != null && !itemEnumValues.isEmpty()) {
            for (int i = 0; i < items.size(); i++) {
                String item = items.get(i);
                if (!itemEnumValues.contains(item)) {
                    errors.add(new ValidationError(paramName + "[" + i + "]", item, "enum",
                        paramName + "[" + i + "] must be one of: " + String.join(", ", itemEnumValues)));
                }
            }
        }

        return errors;
    }

    /**
     * Validates string format according to OpenAPI specification.
     *
     * <p>Supported formats (as per OpenAPI 3.0 spec):
     * <ul>
     *   <li>email - RFC 5322 email address</li>
     *   <li>uuid - RFC 4122 UUID</li>
     *   <li>uri - RFC 3986 URI</li>
     *   <li>uri-reference - URI or relative reference</li>
     *   <li>hostname - RFC 1123 hostname</li>
     *   <li>ipv4 - IPv4 address (dotted decimal)</li>
     *   <li>ipv6 - IPv6 address</li>
     * </ul>
     *
     * @param paramName parameter name for error messages
     * @param value string value to validate (may be null)
     * @param required whether parameter is required
     * @param format OpenAPI format specification (e.g., "email", "uuid")
     * @return list of validation errors (empty if valid)
     */
    public static List<ValidationError> validateFormat(
            String paramName,
            String value,
            boolean required,
            String format) {

        List<ValidationError> errors = new ArrayList<>();

        if (required && (value == null || value.isEmpty())) {
            errors.add(new ValidationError(paramName, value, "required",
                paramName + " is required"));
            return errors;
        }

        if (value == null || value.isEmpty() || format == null) {
            return errors;
        }

        switch (format.toLowerCase()) {
            case "email":
                if (!isValidEmail(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid email address"));
                }
                break;

            case "uuid":
                if (!isValidUuid(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid UUID"));
                }
                break;

            case "uri":
            case "uri-reference":
                if (!isValidUri(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid URI"));
                }
                break;

            case "hostname":
                if (!isValidHostname(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid hostname"));
                }
                break;

            case "ipv4":
                if (!isValidIpv4(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid IPv4 address"));
                }
                break;

            case "ipv6":
                if (!isValidIpv6(value)) {
                    errors.add(new ValidationError(paramName, value, "format",
                        paramName + " must be valid IPv6 address"));
                }
                break;

            default:
                // Unknown format - skip validation
                break;
        }

        return errors;
    }

    /**
     * Validates email format (simplified RFC 5322 pattern).
     */
    private static boolean isValidEmail(String email) {
        // Simplified email pattern - covers most common cases
        String emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        Pattern pattern = PATTERN_CACHE.computeIfAbsent(emailPattern, Pattern::compile);
        return pattern.matcher(email).matches();
    }

    /**
     * Validates UUID format (RFC 4122).
     * Accepts lowercase, uppercase, with or without hyphens.
     */
    private static boolean isValidUuid(String uuid) {
        String uuidPattern = "^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$";
        Pattern pattern = PATTERN_CACHE.computeIfAbsent(uuidPattern, Pattern::compile);
        return pattern.matcher(uuid).matches();
    }

    /**
     * Validates URI format (RFC 3986).
     * Simplified pattern accepting most common URIs.
     */
    private static boolean isValidUri(String uri) {
        try {
            new java.net.URI(uri);
            return true;
        } catch (java.net.URISyntaxException e) {
            return false;
        }
    }

    /**
     * Validates hostname format (RFC 1123).
     */
    private static boolean isValidHostname(String hostname) {
        // RFC 1123 hostname pattern
        String hostnamePattern = "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$";
        Pattern pattern = PATTERN_CACHE.computeIfAbsent(hostnamePattern, Pattern::compile);
        return pattern.matcher(hostname).matches() && hostname.length() <= 253;
    }

    /**
     * Validates IPv4 address (dotted decimal notation).
     */
    private static boolean isValidIpv4(String ipv4) {
        String ipv4Pattern = "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$";
        Pattern pattern = PATTERN_CACHE.computeIfAbsent(ipv4Pattern, Pattern::compile);
        return pattern.matcher(ipv4).matches();
    }

    /**
     * Validates IPv6 address.
     * Supports full form, compressed form, and IPv4-mapped IPv6.
     */
    private static boolean isValidIpv6(String ipv6) {
        // Simplified IPv6 pattern - covers most common cases
        // Full form: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
        // Compressed: 2001:db8::1
        // IPv4-mapped: ::ffff:192.0.2.1
        String ipv6Pattern = "^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|" +
                            "([0-9a-fA-F]{1,4}:){1,7}:|" +
                            "([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|" +
                            "([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|" +
                            "([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|" +
                            "([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|" +
                            "([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|" +
                            "[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|" +
                            ":((:[0-9a-fA-F]{1,4}){1,7}|:)|" +
                            "fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|" +
                            "::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$";
        Pattern pattern = PATTERN_CACHE.computeIfAbsent(ipv6Pattern, Pattern::compile);
        return pattern.matcher(ipv6).matches();
    }
}
